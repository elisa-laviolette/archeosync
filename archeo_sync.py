# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ArcheoSync
                                 A QGIS plugin
 This plugin allows archaeologists to prepare data for the field and to import it back into the project
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Elisa Caron-Laviolette
        email                : elisa.laviolette@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
from typing import List, Optional, Dict

from qgis.PyQt.QtCore import QSettings
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QDockWidget

# Initialize Qt resources from file resources.py
from .resources import *
from .ui.settings_dialog import SettingsDialog
from .ui.prepare_recording_dialog import PrepareRecordingDialog
from .ui.import_data_dialog import ImportDataDialog
from .ui.column_mapping_dialog import ColumnMappingDialog
from .services import (
    QGISSettingsManager,
    QGISFileSystemService,
    QGISTranslationService,
    ArcheoSyncConfigurationValidator,
    QGISLayerService,
    CSVImportService,
    QGISRasterProcessingService,
    QGISProjectCreationService,
    FieldProjectImportService
)


class ArcheoSyncPlugin:
    """
    ArcheoSync QGIS Plugin.
    
    All user-facing strings are wrapped in self.tr() for translation.
    """
    
    def __init__(self, iface):
        """
        Initialize the plugin.
        
        Args:
            iface: QGIS interface instance
        """
        self._iface = iface
        self._plugin_dir = os.path.dirname(__file__)
        
        # Initialize services using dependency injection
        self._initialize_services()
        
        # Plugin state
        self._actions: List[QAction] = []
        self._first_start = True
        self._settings_dialog: Optional[SettingsDialog] = None
        self._import_data_dialog: Optional[ImportDataDialog] = None
    
    def _initialize_services(self) -> None:
        """Initialize all required services."""
        # Initialize translation service
        self._translation_service = QGISTranslationService(
            self._plugin_dir, 
            'ArcheoSyncPlugin'
        )
        
        # Initialize settings manager
        self._settings_manager = QGISSettingsManager('ArcheoSync')
        
        # Initialize file system service
        self._file_system_service = QGISFileSystemService(self._iface.mainWindow())
        
        # Initialize layer service
        self._layer_service = QGISLayerService()

        # Initialize raster processing service FIRST
        self._raster_processing_service = QGISRasterProcessingService()

        # Initialize project creation service
        self._project_creation_service = QGISProjectCreationService(
            self._settings_manager,
            self._layer_service,
            self._file_system_service,
            self._raster_processing_service,
            self._translation_service
        )
        
        # Initialize CSV import service
        self._csv_import_service = CSVImportService(self._iface, self._file_system_service, self._settings_manager)
        
        # Initialize field project import service
        self._field_project_import_service = FieldProjectImportService(
            self._settings_manager,
            self._layer_service,
            self._file_system_service,
            self._translation_service
        )
        
        # Initialize configuration validator
        self._configuration_validator = ArcheoSyncConfigurationValidator(
            self._file_system_service,
            self._layer_service
        )
    
    def tr(self, message: str) -> str:
        """
        Get the translation for a string.
        
        Args:
            message: String for translation
            
        Returns:
            Translated version of message
        """
        return self._translation_service.translate(message)
    
    def add_action(
        self,
        icon_path: str,
        text: str,
        callback: callable,
        enabled_flag: bool = True,
        add_to_menu: bool = True,
        add_to_toolbar: bool = True,
        status_tip: Optional[str] = None,
        whats_this: Optional[str] = None,
        parent=None
    ) -> QAction:
        """
        Add a toolbar icon to the toolbar.
        
        Args:
            icon_path: Path to the icon for this action
            text: Text that should be shown in menu items for this action
            callback: Function to be called when the action is triggered
            enabled_flag: A flag indicating if the action should be enabled by default
            add_to_menu: Flag indicating whether the action should also be added to the menu
            add_to_toolbar: Flag indicating whether the action should also be added to the toolbar
            status_tip: Optional text to show in a popup when mouse pointer hovers over the action
            whats_this: Optional text to show in the status bar when the action is triggered
            parent: Parent widget for the action
            
        Returns:
            The action that was created
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        
        if status_tip is not None:
            action.setStatusTip(self.tr(status_tip))
        
        if whats_this is not None:
            action.setWhatsThis(self.tr(whats_this))
        
        if add_to_toolbar:
            self._iface.addToolBarIcon(action)
        
        if add_to_menu:
            self._iface.addPluginToMenu(self.tr(u'&ArcheoSync'), action)
        
        self._actions.append(action)
        return action
    
    def initGui(self) -> None:
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/archeo_sync/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Configuration'),
            callback=self.run,
            parent=self._iface.mainWindow()
        )
        
        # Add Prepare Recording menu item
        self.add_action(
            icon_path,
            text=self.tr(u'Prepare Recording'),
            callback=self.run_prepare_recording,
            parent=self._iface.mainWindow()
        )
        
        # Add Import Data menu item
        self.add_action(
            icon_path,
            text=self.tr(u'Import Data'),
            callback=self.run_import_data,
            parent=self._iface.mainWindow()
        )
    
    def unload(self) -> None:
        """Remove the plugin menu item and icon from QGIS GUI."""
        for action in self._actions:
            self._iface.removePluginMenu(self.tr(u'&ArcheoSync'), action)
            self._iface.removeToolBarIcon(action)
    
    def run(self) -> None:
        """Run method that performs all the real work."""
        # Create the dialog only once
        if self._first_start:
            self._first_start = False
            self._settings_dialog = SettingsDialog(
                settings_manager=self._settings_manager,
                file_system_service=self._file_system_service,
                layer_service=self._layer_service,
                configuration_validator=self._configuration_validator,
                parent=self._iface.mainWindow()
            )
        
        # Show the dialog
        if self._settings_dialog:
            result = self._settings_dialog.exec_()
            
            # Handle dialog result
            if result:
                self._handle_settings_accepted()
    
    def _handle_settings_accepted(self) -> None:
        """Handle the case when settings dialog is accepted."""
        # This is where you would implement the actual plugin functionality
        # based on the saved settings
        pass
    
    def run_prepare_recording(self) -> None:
        """Run the prepare recording dialog."""
        # Create and show the prepare recording dialog
        dialog = PrepareRecordingDialog(
            layer_service=self._layer_service,
            settings_manager=self._settings_manager,
            parent=self._iface.mainWindow()
        )
        
        result = dialog.exec_()
        
        # Handle dialog result
        if result:
            self._handle_prepare_recording_accepted(dialog)
    
    def _handle_prepare_recording_accepted(self, dialog) -> None:
        """Handle the case when prepare recording dialog is accepted."""
        try:
            
            # Get configuration
            recording_areas_layer_id = self._settings_manager.get_value('recording_areas_layer', '')
            objects_layer_id = self._settings_manager.get_value('objects_layer', '')
            features_layer_id = self._settings_manager.get_value('features_layer', '')
            small_finds_layer_id = self._settings_manager.get_value('small_finds_layer', '')
            destination_folder = self._settings_manager.get_value('field_projects_folder', '')
            
            if not recording_areas_layer_id or not objects_layer_id or not destination_folder:
                from qgis.PyQt.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self._iface.mainWindow(),
                    self.tr("Configuration Error"),
                    self.tr("Required configuration is missing. Please check your settings.")
                )
                return
            
            # Get selected features and extract their data early to avoid QGIS object deletion issues
            recording_layer = self._layer_service.get_layer_by_id(recording_areas_layer_id)
            if not recording_layer:
                from qgis.PyQt.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self._iface.mainWindow(),
                    self.tr("Layer Error"),
                    self.tr("Recording areas layer not found.")
                )
                return
            
            selected_features = recording_layer.selectedFeatures()
            if not selected_features:
                from qgis.PyQt.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self._iface.mainWindow(),
                    self.tr("No Selection"),
                    self.tr("No recording areas are selected.")
                )
                return
            
            # Extract feature data early to avoid issues with QGIS object deletion
            feature_data = []
            layer_display_expression = recording_layer.displayExpression()
            
            for feature in selected_features:
                # Extract geometry as WKT
                geometry_wkt = None
                if hasattr(feature, 'geometry') and feature.geometry():
                    geom = feature.geometry()
                    if geom and not geom.isNull():
                        geometry_wkt = geom.asWkt()
                
                # Extract attributes as a list to preserve order
                attributes = []
                if hasattr(feature, 'attributes'):
                    attributes = list(feature.attributes())
                
                # Extract feature ID
                feature_id = feature.id() if hasattr(feature, 'id') else None
                
                # Get display name using QGIS expression evaluation
                display_name = str(feature_id)  # Default to feature ID
                if layer_display_expression and layer_display_expression.strip():
                    try:
                        from qgis.core import QgsExpression, QgsExpressionContext, QgsExpressionContextUtils
                        expr = QgsExpression(layer_display_expression)
                        if not expr.hasParserError():
                            context = QgsExpressionContext()
                            context.appendScope(QgsExpressionContextUtils.layerScope(recording_layer))
                            context.setFeature(feature)
                            result = expr.evaluate(context)
                            if result and str(result) != 'NULL' and str(result).strip():
                                display_name = str(result).strip()
                                print(f"Using display expression for feature {feature_id}: '{display_name}'")
                    except Exception as e:
                        print(f"Display expression evaluation failed for feature {feature_id}: {str(e)}")
                        # Fall back to common name fields
                        name_fields = ['name', 'title', 'label', 'description', 'comment']
                        for field_name in name_fields:
                            field_idx = recording_layer.fields().indexOf(field_name)
                            if field_idx >= 0 and field_idx < len(attributes):
                                value = attributes[field_idx]
                                if value and str(value) != 'NULL':
                                    display_name = str(value)
                                    print(f"Using common name field '{field_name}' for feature {feature_id}: '{display_name}'")
                                    break
                
                feature_data.append({
                    'id': feature_id,
                    'geometry_wkt': geometry_wkt,
                    'attributes': attributes,
                    'display_name': display_name
                })
            
            # Get next values for all features
            next_values = dialog.get_all_next_values()
            
            # Display expression information for debugging
            if layer_display_expression and layer_display_expression.strip():
                print(f"Display expression: '{layer_display_expression}'")
            
            # Process each selected recording area
            success_count = 0
            error_count = 0
            
            for i, feature_info in enumerate(feature_data):
                try:
                    # Use the pre-extracted display name
                    feature_name = feature_info['display_name']
                    
                    # Get level from next values
                    level = next_values[i].get('level', '') if i < len(next_values) else ''
                    
                    # Create project name: display name + '_' + level (if level is defined)
                    if level:
                        project_name = f"{feature_name}_{level}"
                    else:
                        project_name = feature_name
                    
                    # Clean project name for file system
                    import re
                    project_name = re.sub(r'[^\w\-_\.]', '_', project_name)
                    
                    # Get background image from next values
                    background_layer_id = next_values[i]['background_image'] if i < len(next_values) else ''
                    
                    # Get extra layers from settings
                    extra_layers = self._settings_manager.get_value('extra_field_layers', [])
                    
                    # Create field project using the new project creation service
                    success = self._project_creation_service.create_field_project(
                        feature_data=feature_info,
                        recording_areas_layer_id=recording_areas_layer_id,
                        objects_layer_id=objects_layer_id,
                        features_layer_id=features_layer_id if features_layer_id else None,
                        small_finds_layer_id=small_finds_layer_id if small_finds_layer_id else None,
                        background_layer_id=background_layer_id if background_layer_id else None,
                        extra_layers=extra_layers,
                        destination_folder=destination_folder,
                        project_name=project_name,
                        next_values=next_values[i] if i < len(next_values) else {}
                    )
                    
                    if success:
                        success_count += 1
                    else:
                        error_count += 1
                        
                except Exception as e:
                    feature_id = feature_info.get('id', 'unknown')
                    print(f"Error processing recording area {feature_id}: {str(e)}")
                    error_count += 1
            
            # Show results
            from qgis.PyQt.QtWidgets import QMessageBox
            if error_count == 0:
                QMessageBox.information(
                    self._iface.mainWindow(),
                    self.tr("Field Project Preparation Complete"),
                    self.tr(f"Successfully created {success_count} field project(s) in:\n{destination_folder}")
                )
            else:
                QMessageBox.warning(
                    self._iface.mainWindow(),
                    self.tr("Field Project Preparation Results"),
                    self.tr(f"Created {success_count} field project(s) successfully.\n{error_count} project(s) failed.\n\nCheck the console for error details.")
                )
                
        except Exception as e:
            from qgis.PyQt.QtWidgets import QMessageBox
            QMessageBox.critical(
                self._iface.mainWindow(),
                self.tr("Error"),
                self.tr(f"An error occurred during field project preparation:\n{str(e)}")
            )
    
    def run_import_data(self) -> None:
        """Run the import data dialog."""
        print("Debug: run_import_data called")
        
        # Check if an import summary dock widget already exists
        existing_dock_widget = self._find_existing_import_summary_dock_widget()
        
        if existing_dock_widget:
            print("Debug: Found existing dock widget, showing it")
            # If a dock widget exists, show it and bring it to front
            existing_dock_widget.show()
            existing_dock_widget.raise_()
            existing_dock_widget.activateWindow()
        else:
            print("Debug: No existing dock widget found, creating new dialog")
            # If no dock widget exists, create and show the import data dialog
            dialog = ImportDataDialog(
                settings_manager=self._settings_manager,
                file_system_service=self._file_system_service,
                parent=self._iface.mainWindow()
            )
            
            result = dialog.exec_()
            
            # Handle dialog result
            if result:
                self._handle_import_data_accepted(dialog)
    
    def _handle_import_data_accepted(self, dialog) -> None:
        """Handle the case when import data dialog is accepted."""
        try:
            # Get selected items
            selected_csv_files = dialog.get_selected_csv_files()
            selected_completed_projects = dialog.get_selected_completed_projects()
            
            from qgis.PyQt.QtWidgets import QMessageBox
            
            # Initialize summary data
            summary_data = {
                'csv_points_count': 0,
                'features_count': 0,
                'objects_count': 0,
                'small_finds_count': 0,
                'csv_duplicates': 0,
                'features_duplicates': 0,
                'objects_duplicates': 0,
                'small_finds_duplicates': 0
            }
            
            # Process CSV files if any are selected
            if selected_csv_files:
                csv_result = self._process_csv_files(selected_csv_files)
                if csv_result:
                    summary_data['csv_points_count'] = csv_result
            
            # Process completed projects if any are selected
            if selected_completed_projects:
                project_stats = self._process_completed_projects(selected_completed_projects)
                if project_stats:
                    summary_data.update(project_stats)
            
            # Show summary dialog if any data was imported
            if (summary_data['csv_points_count'] > 0 or 
                summary_data['features_count'] > 0 or 
                summary_data['objects_count'] > 0 or 
                summary_data['small_finds_count'] > 0):
                
                self._show_import_summary(summary_data)
            
        except Exception as e:
            from qgis.PyQt.QtWidgets import QMessageBox
            QMessageBox.critical(
                self._iface.mainWindow(),
                self.tr("Error"),
                self.tr(f"An error occurred during import data processing:\n{str(e)}")
            )
    
    def _process_csv_files(self, csv_files: List[str]) -> Optional[int]:
        """Process CSV files for import."""
        from qgis.PyQt.QtWidgets import QMessageBox
        
        # Validate CSV files
        validation_result = self._csv_import_service.validate_csv_files(csv_files)
        if not validation_result.is_valid:
            QMessageBox.critical(
                self._iface.mainWindow(),
                self.tr("CSV Validation Error"),
                validation_result.message
            )
            return None
        
        # Get column mapping and all headers
        column_mapping, file_columns = self._csv_import_service.get_column_mapping_and_headers(csv_files)
        
        # Check if columns differ across files
        columns_differ = False
        for column_name, column_list in column_mapping.items():
            if len(set(column_list)) > 1:  # More than one unique column name
                columns_differ = True
                break
        
        # If columns differ, show column mapping dialog
        if columns_differ:
            mapping_dialog = ColumnMappingDialog(
                column_mapping=column_mapping,
                csv_files=csv_files,
                file_columns=file_columns,
                parent=self._iface.mainWindow()
            )
            
            if mapping_dialog.exec_() != mapping_dialog.Accepted:
                return None  # User cancelled
            
            # Get final mapping from dialog
            column_mapping = mapping_dialog.get_final_mapping()
        
        # Import CSV files
        import_result = self._csv_import_service.import_csv_files(csv_files, column_mapping)
        
        if import_result.is_valid:
            # Return the number of imported features
            return self._csv_import_service.get_last_import_count()
        else:
            QMessageBox.critical(
                self._iface.mainWindow(),
                self.tr("CSV Import Error"),
                import_result.message
            )
            return None
    
    def _process_completed_projects(self, project_paths: List[str]) -> Optional[Dict[str, int]]:
        """Process completed field projects for import."""
        from qgis.PyQt.QtWidgets import QMessageBox
        
        # Import field projects using the field project import service
        import_result = self._field_project_import_service.import_field_projects(project_paths)
        
        if import_result.is_valid:
            # Return the import statistics
            return self._field_project_import_service.get_last_import_stats()
        else:
            QMessageBox.critical(
                self._iface.mainWindow(),
                self.tr("Field Project Import Error"),
                import_result.message
            )
            return None
    
    def _show_import_summary(self, summary_data: Dict[str, int]) -> None:
        """Show the import summary dock widget."""
        try:
            from .ui.import_summary_dialog import ImportSummaryDockWidget, ImportSummaryData
            from .services.duplicate_objects_detector_service import DuplicateObjectsDetectorService
            from .services.skipped_numbers_detector_service import SkippedNumbersDetectorService
            from .services.out_of_bounds_detector_service import OutOfBoundsDetectorService
            from .services.distance_detector_service import DistanceDetectorService
            from qgis.PyQt.QtCore import Qt
            
            # Detect duplicate objects if objects were imported
            duplicate_objects_warnings = []
            if summary_data.get('objects_count', 0) > 0:
                detector = DuplicateObjectsDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                duplicate_objects_warnings = detector.detect_duplicate_objects()
            
            # Detect skipped numbers if objects were imported
            skipped_numbers_warnings = []
            if summary_data.get('objects_count', 0) > 0:
                skipped_detector = SkippedNumbersDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                skipped_numbers_warnings = skipped_detector.detect_skipped_numbers()
            
            # Detect out-of-bounds features if any features were imported
            out_of_bounds_warnings = []
            if (summary_data.get('objects_count', 0) > 0 or 
                summary_data.get('features_count', 0) > 0 or 
                summary_data.get('small_finds_count', 0) > 0):
                print(f"[DEBUG] Running out-of-bounds detection in main plugin")
                print(f"[DEBUG] Summary data: {summary_data}")
                out_of_bounds_detector = OutOfBoundsDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                out_of_bounds_warnings = out_of_bounds_detector.detect_out_of_bounds_features()
                print(f"[DEBUG] Out-of-bounds detection completed, found {len(out_of_bounds_warnings)} warnings")
                for i, warning in enumerate(out_of_bounds_warnings):
                    print(f"[DEBUG] Out-of-bounds warning {i+1}: {warning}")
                    if hasattr(warning, 'message'):
                        print(f"[DEBUG]   Message: {warning.message}")
            else:
                print(f"[DEBUG] Skipping out-of-bounds detection - no features imported")
            
            # Detect distance warnings if both total station points and objects were imported
            distance_warnings = []
            if (summary_data.get('csv_points_count', 0) > 0 and 
                summary_data.get('objects_count', 0) > 0):
                print(f"[DEBUG] Running distance detection in main plugin")
                distance_detector = DistanceDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                distance_warnings = distance_detector.detect_distance_warnings()
                print(f"[DEBUG] Distance detection completed, found {len(distance_warnings)} warnings")
                for i, warning in enumerate(distance_warnings):
                    print(f"[DEBUG] Distance warning {i+1}: {warning}")
                    if hasattr(warning, 'message'):
                        print(f"[DEBUG]   Message: {warning.message}")
            else:
                print(f"[DEBUG] Skipping distance detection - missing total station points or objects")
            
            # Run missing total station detection if both total station points and objects were imported
            missing_total_station_warnings = []
            if (summary_data.get('csv_points_count', 0) > 0 and 
                summary_data.get('objects_count', 0) > 0):
                print(f"[DEBUG] Running missing total station detection in main plugin")
                try:
                    from services.missing_total_station_detector_service import MissingTotalStationDetectorService
                except ImportError:
                    # Fallback for relative import
                    import sys
                    import os
                    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
                    from services.missing_total_station_detector_service import MissingTotalStationDetectorService
                
                missing_total_station_detector = MissingTotalStationDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                missing_total_station_warnings = missing_total_station_detector.detect_missing_total_station_warnings()
                print(f"[DEBUG] Missing total station detection completed, found {len(missing_total_station_warnings)} warnings")
                for i, warning in enumerate(missing_total_station_warnings):
                    print(f"[DEBUG] Missing total station warning {i+1}: {warning}")
                    if hasattr(warning, 'message'):
                        print(f"[DEBUG]   Message: {warning.message}")
            else:
                print(f"[DEBUG] Skipping missing total station detection - missing total station points or objects")
            
            # Run duplicate total station identifiers detection if total station points were imported
            duplicate_total_station_identifiers_warnings = []
            if summary_data.get('csv_points_count', 0) > 0:
                print(f"[DEBUG] Running duplicate total station identifiers detection in main plugin")
                try:
                    # Force reload of the module
                    import sys
                    import importlib
                    if 'services.duplicate_total_station_identifiers_detector_service' in sys.modules:
                        importlib.reload(sys.modules['services.duplicate_total_station_identifiers_detector_service'])
                    from services.duplicate_total_station_identifiers_detector_service import DuplicateTotalStationIdentifiersDetectorService
                except ImportError:
                    # Fallback for relative import
                    import sys
                    import os
                    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
                    from services.duplicate_total_station_identifiers_detector_service import DuplicateTotalStationIdentifiersDetectorService
                
                duplicate_total_station_identifiers_detector = DuplicateTotalStationIdentifiersDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                duplicate_total_station_identifiers_warnings = duplicate_total_station_identifiers_detector.detect_duplicate_identifiers_warnings()
                print(f"[DEBUG] Duplicate total station identifiers detection completed, found {len(duplicate_total_station_identifiers_warnings)} warnings")
                for i, warning in enumerate(duplicate_total_station_identifiers_warnings):
                    print(f"[DEBUG] Duplicate total station identifiers warning {i+1}: {warning}")
                    if hasattr(warning, 'message'):
                        print(f"[DEBUG]   Message: {warning.message}")
            else:
                print(f"[DEBUG] Skipping duplicate total station identifiers detection - no total station points imported")
            
            # Run height difference detection if total station points were imported
            height_difference_warnings = []
            if summary_data.get('csv_points_count', 0) > 0:
                print(f"[DEBUG] Running height difference detection in main plugin")
                try:
                    from services.height_difference_detector_service import HeightDifferenceDetectorService
                except ImportError:
                    # Fallback for relative import
                    import sys
                    import os
                    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
                    from services.height_difference_detector_service import HeightDifferenceDetectorService
                
                height_difference_detector = HeightDifferenceDetectorService(
                    settings_manager=self._settings_manager,
                    layer_service=self._layer_service,
                    translation_service=self._translation_service
                )
                height_difference_warnings = height_difference_detector.detect_height_difference_warnings()
                print(f"[DEBUG] Height difference detection completed, found {len(height_difference_warnings)} warnings")
                for i, warning in enumerate(height_difference_warnings):
                    print(f"[DEBUG] Height difference warning {i+1}: {warning}")
                    if hasattr(warning, 'message'):
                        print(f"[DEBUG]   Message: {warning.message}")
            else:
                print(f"[DEBUG] Skipping height difference detection - no total station points imported")
            
            # Create summary data
            summary = ImportSummaryData(
                csv_points_count=summary_data.get('csv_points_count', 0),
                features_count=summary_data.get('features_count', 0),
                objects_count=summary_data.get('objects_count', 0),
                small_finds_count=summary_data.get('small_finds_count', 0),
                csv_duplicates=summary_data.get('csv_duplicates', 0),
                features_duplicates=summary_data.get('features_duplicates', 0),
                objects_duplicates=summary_data.get('objects_duplicates', 0),
                small_finds_duplicates=summary_data.get('small_finds_duplicates', 0)
            )
            
            # Add warnings to summary data
            summary.duplicate_objects_warnings = duplicate_objects_warnings
            summary.skipped_numbers_warnings = skipped_numbers_warnings
            summary.out_of_bounds_warnings = out_of_bounds_warnings
            summary.distance_warnings = distance_warnings
            summary.missing_total_station_warnings = missing_total_station_warnings
            summary.duplicate_total_station_identifiers_warnings = duplicate_total_station_identifiers_warnings
            summary.height_difference_warnings = height_difference_warnings
            
            print(f"[DEBUG] Summary data warnings - duplicates: {len(duplicate_objects_warnings)}, skipped: {len(skipped_numbers_warnings)}, out-of-bounds: {len(out_of_bounds_warnings)}")
            print(f"[DEBUG] Summary object attributes: {dir(summary)}")
            print(f"[DEBUG] Summary out_of_bounds_warnings attribute: {hasattr(summary, 'out_of_bounds_warnings')}")
            if hasattr(summary, 'out_of_bounds_warnings'):
                print(f"[DEBUG] Summary out_of_bounds_warnings value: {summary.out_of_bounds_warnings}")
            
            # Create and show the dock widget
            dock_widget = ImportSummaryDockWidget(
                summary, 
                iface=self._iface, 
                settings_manager=self._settings_manager,
                csv_import_service=self._csv_import_service,
                field_project_import_service=self._field_project_import_service,
                layer_service=self._layer_service,
                translation_service=self._translation_service,
                parent=self._iface.mainWindow()
            )
            
            # Add the dock widget to the main window
            self._iface.addDockWidget(Qt.RightDockWidgetArea, dock_widget)
            
        except Exception as e:
            print(f"Error showing import summary: {e}")
            import traceback
            traceback.print_exc()
    
    def _find_existing_import_summary_dock_widget(self):
        """
        Find an existing import summary dock widget.
        
        Returns:
            The existing dock widget if found, None otherwise
        """
        try:
            # Get the main window
            main_window = self._iface.mainWindow()
            if not main_window:
                print("Debug: No main window found")
                return None
            
            # Look for dock widgets that are instances of ImportSummaryDockWidget
            dock_widgets = main_window.findChildren(QDockWidget)
            print(f"Debug: Found {len(dock_widgets)} dock widgets")
            
            for child in dock_widgets:
                # Check if this is an ImportSummaryDockWidget by checking the class name
                if hasattr(child, '__class__') and 'ImportSummaryDockWidget' in child.__class__.__name__:
                    print(f"Debug: Found ImportSummaryDockWidget by class name: {child.__class__.__name__}")
                    return child
                
                # Also check the window title as a fallback (both translated and untranslated)
                title = child.windowTitle()
                print(f"Debug: Dock widget title: '{title}'")
                if title in ["Import Summary", self.tr("Import Summary")]:
                    print(f"Debug: Found ImportSummaryDockWidget by title: '{title}'")
                    return child
            
            print("Debug: No ImportSummaryDockWidget found")
            return None
            
        except Exception as e:
            print(f"Error finding existing import summary dock widget: {e}")
            return None
    
    @property
    def settings_manager(self):
        """Get the settings manager instance."""
        return self._settings_manager
    
    @property
    def translation_service(self):
        """Get the translation service instance."""
        return self._translation_service
    
    @property
    def layer_service(self):
        """Get the layer service instance."""
        return self._layer_service
    

    
    @property
    def project_creation_service(self):
        """Get the project creation service instance."""
        return self._project_creation_service
    
    @property
    def csv_import_service(self):
        """Get the CSV import service instance."""
        return self._csv_import_service 